// count only the number of appearences of the character
const counter = (text, char) => {
  return text.split("").filter((c) => c === char).length;
};

// text only has the same character
const sameChar = (text, char) => {
  return text.split("").every((c) => c === char);
};

// parse headings and transform them to h# tags
const headingsTransform = (text, char) => {
  return counter(text.split(" ")[0], char) < 7 &&
    sameChar(text.split(" ")[0], char)
    ? `<h${counter(text.split(" ")[0], char)}> ${text
        .split(" ")
        .slice(1)
        .join(" ")} </h${counter(text.split(" ")[0], char)}>`
    : text;
};

// use cases regexTransform function
// regex generated by copilot
//  - italic using asterisk:         tag = "em"      regex = '/\*(.*?)\*/g'
//  - bold   using asterisk:         tag = "strong"  regex = /\*\*(.*?)\*\*/g
//  - strikethrough using 2 tildes:  tag = "del"     regex = '/~~(.*?)~~/g'
//  - code   using 2 backticks:      tag = "code"    regex = '/``(.*?)``/g'

// based on https://davidwells.io/snippets/regex-match-markdown-links
//  - link   using brackets:         tag = "a"       regex = '/\[([\w\s\d]+)\]\((https?:\/\/[\w\d./?=#]+)\)/;'


const italicRegex = /\*(.*?)\*/g;
const boldRegex = /\*\*(.*?)\*\*/g;
const strikethroughRegex = /~~(.*?)~~/g;
const linkRegex = /\[([\w\s\d]+)\]\((https?:\/\/[\w\d./?=#]+)\)/;
                    
const regexTransform = (regex, tag, text) =>
  text.replace(regex, `<${tag}>$1</${tag}>`);

// match number. and space at the start of the line
const OrderRegex = /^(\d+\.\s)/;
const UnorderRegex = /^(\*\s)|^(\-\s)|^(\+\s)/;

const listElements = (regex) => (text) => {
  return text
    .split("\n")
    .map((item) => {
      return regex.test(item) ? `<li>${item.slice(3)}</li>` : item;
    })
    .join("\n");
};

const orderElements = listElements(OrderRegex);
const unorderElements = listElements(UnorderRegex);

const listTransform = (elements, tag) => {
  return `<${tag}>\n${elements}</${tag}>`;
};
